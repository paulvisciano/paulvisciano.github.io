<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="0">
    <!-- Disable service worker caching -->
    <meta name="service-worker" content="no-cache">
    <title>Jarvis Neural Mind [FRESH - 2026-02-22-15:43]</title>
    <!-- Deployment verification: 2026-02-22 15:31:58 UTC -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a1128; 
            color: #00ffff; 
            font-family: monospace; 
            overflow: hidden;
        }
        canvas { 
            display: block; 
            margin-right: 240px;
            margin-top: 50px;
            background: radial-gradient(ellipse at center, #0f1a3a 0%, #0a0f20 50%, #000000 100%);
            filter: brightness(1.1);
            touch-action: none;
            transition: margin-right 0.25s ease, margin-bottom 0.3s ease;
        }
        
        @media (max-width: 768px) {
            canvas {
                margin-right: 0;
                margin-bottom: 0;
                transition: margin-bottom 0.3s ease;
            }
            canvas.drawer-open {
                margin-bottom: 60vh;
            }
        }
        #filter-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 240px;
            height: 50px;
            background: rgba(10, 17, 40, 0.95);
            border-bottom: 2px solid rgba(0, 255, 255, 0.4);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 16px;
            z-index: 12;
            transition: right 0.25s ease;
        }
        
        @media (max-width: 768px) {
            #filter-bar {
                right: 0;
            }
        }
        .filter-btn {
            background: rgba(0, 136, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            padding: 8px 14px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 11px;
            font-family: monospace;
            font-weight: bold;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: #00ffff;
        }
        .filter-btn.active {
            background: linear-gradient(135deg, #0088ff, #00ffff);
            border-color: #00ffff;
            color: #000;
            text-shadow: none;
        }
        
        /* Mobile Bottom Drawer */
        .bottom-drawer {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 26, 48, 0.98);
            border-top: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 20px 20px 0 0;
            max-height: 70vh;
            z-index: 20;
            flex-direction: column;
            animation: slideUp 0.3s ease-out;
            touch-action: none;
        }
        
        .bottom-drawer.open {
            display: flex;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }
            to {
                transform: translateY(0);
            }
        }
        
        .drawer-handle {
            width: 40px;
            height: 5px;
            background: rgba(0, 255, 255, 0.3);
            border-radius: 3px;
            margin: 12px auto 16px;
            cursor: grab;
        }
        
        .drawer-filters {
            display: flex;
            gap: 8px;
            padding: 0 16px 16px;
            overflow-x: auto;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }
        
        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        #drawerDetails {
            color: #00ffff;
        }
        
        /* Show drawer on mobile only */
        @media (max-width: 768px) {
            #detailPanel {
                display: none !important;
            }
        }
        
        @media (min-width: 769px) {
            .bottom-drawer {
                display: none !important;
            }
        }
        #info {
            --panel-gap: 14px;
            --panel-divider: 1px solid rgba(0, 255, 255, 0.25);
            position: fixed;
            right: 0;
            top: 0;
            width: 240px;
            height: 100vh;
            background: rgba(10, 17, 40, 0.98);
            padding: 14px 16px;
            border-left: 2px solid rgba(0, 255, 255, 0.6);
            font-size: 11px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
            z-index: 10;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            gap: 0;
            transition: transform 0.25s ease, width 0.25s ease;
        }
        
        @media (max-width: 768px) {
            #info {
                position: fixed;
                bottom: 0;
                right: 0;
                left: 0;
                top: auto;
                width: 100%;
                height: auto;
                min-height: 60vh;
                max-height: 70vh;
                border-left: none;
                border-top: 2px solid rgba(0, 255, 255, 0.6);
                border-radius: 20px 20px 0 0;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            #info.open {
                transform: translateY(0);
            }
            #panel-toggle {
                display: none !important;
            }
        }
        #info.collapsed {
            transform: translateX(100%);
            pointer-events: none;
        }
        #panel-toggle {
            position: fixed;
            right: 240px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 11;
            width: 36px;
            height: 56px;
            border: 2px solid #00ffff;
            border-right: none;
            border-radius: 8px 0 0 8px;
            background: rgba(10, 17, 40, 0.95);
            color: #00ffff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            transition: right 0.25s ease, background 0.2s;
        }
        #panel-toggle:hover { background: rgba(0, 136, 255, 0.3); }
        #info.collapsed ~ #panel-toggle { right: 0; }
        #info .panel-top { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; gap: var(--panel-gap); }
        #info .panel-top .panel-top-content { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; gap: var(--panel-gap); }
        #info .panel-top .panel-buttons { flex: 0 0 auto; }
        #info .panel-legend { flex: 0 0 auto; padding-top: var(--panel-gap); border-top: var(--panel-divider); }
        .panel-header { margin-bottom: 2px; }
        .panel-header h3 { margin: 0 0 4px 0; color: #00ffff; font-size: 15px; text-shadow: 0 0 12px #00ffff; font-weight: bold; }
        .panel-header .tagline { color: #0088ff; font-size: 9px; margin: 0; }
        .panel-status { font-size: 11px; margin: 0; min-height: 1.4em; }
        .panel-status .stat { color: #ffff88; font-weight: bold; text-shadow: 0 0 8px #ffff88; }
        .panel-meta { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; font-size: 10px; color: #0088ff; margin: 0; }
        .panel-meta .stat { color: #00ffff; font-weight: bold; }
        h3 { margin: 0 0 6px 0; color: #00ffff; font-size: 12px; text-shadow: 0 0 10px #00ffff; font-weight: bold; }
        p { margin: 0; line-height: 1.5; }
        button.primary {
            background: linear-gradient(135deg, #0088ff, #00ffff);
            color: #000;
            padding: 8px 12px;
            border: 0;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            font-family: monospace;
            transition: all 0.2s;
            width: 100%;
            box-shadow: 0 0 8px rgba(0, 136, 255, 0.5);
        }
        button.primary:hover {
            background: linear-gradient(135deg, #00ffff, #00ffff);
            box-shadow: 0 0 18px #00ffff;
            transform: scale(1.02);
        }
        .stat { color: #00ffff; font-weight: bold; text-shadow: 0 0 10px #00ffff; }
        .desc { color: #0088ff; font-size: 9px; }
        .collapsible-trigger {
            background: none;
            border: none;
            color: #00ffff;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            text-align: left;
            padding: 6px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-family: inherit;
            margin: 0;
        }
        .collapsible-trigger:hover { text-shadow: 0 0 8px #00ffff; color: #00ffff; }
        .collapsible-body { max-height: 0; overflow: hidden; transition: max-height 0.2s ease; }
        .collapsible-body.open { max-height: 120px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .collapsible-body.open.legend-open { max-height: 140px; }
        #detailPanel {
            flex: 1 1 auto;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            padding-top: var(--panel-gap);
            border-top: var(--panel-divider);
            -webkit-overflow-scrolling: touch;
        }
        #detailPanel.is-empty {
            display: none;
        }
        #detailPanel .detail-inner { font-size: 10px; line-height: 1.7; }
        .panel-buttons {
            padding-top: var(--panel-gap);
            border-top: var(--panel-divider);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .filter-section { padding-top: var(--panel-gap); border-top: var(--panel-divider); }
        .filter-toggle {
            background: none;
            border: none;
            color: #00ffff;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            text-align: left;
            padding: 6px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-family: inherit;
            margin: 0;
        }
        .filter-toggle:hover { text-shadow: 0 0 10px #00ffff; }
        .filter-list { max-height: 0; overflow: hidden; transition: max-height 0.25s ease; }
        .filter-list.open { max-height: 240px; overflow-y: auto; -webkit-overflow-scrolling: touch; margin-top: 8px; }
        .filter-category { margin-top: 10px; }
        .filter-category h4 { font-size: 10px; color: #0088ff; margin-bottom: 4px; text-transform: uppercase; }
        .filter-node {
            display: block;
            width: 100%;
            text-align: left;
            padding: 5px 8px;
            margin: 2px 0;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-family: inherit;
            cursor: pointer;
            background: rgba(0, 255, 255, 0.06);
            color: inherit;
            transition: background 0.2s;
        }
        .filter-node:hover { background: rgba(0, 255, 255, 0.18); }
        .legend-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 12px; font-size: 9px; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    </style>
</head>
<body>
    <div id="info">
        <div class="panel-top">
        <div class="panel-top-content">
        <div class="panel-header">
            <h3>‚ö° Neural Mind</h3>
            <p class="tagline">Your memories. Alive. Connected.</p>
        </div>
        <p class="panel-status" id="status">‚Äî</p>
        <p class="panel-meta">
            <span class="stat" id="count">0</span> <span class="desc">neurons</span>
        </p>
        <div>
            <button type="button" class="collapsible-trigger" id="howto-toggle" aria-expanded="false" aria-controls="howto-body">
                <span>How to use</span>
                <span id="howto-chevron">‚ñº</span>
            </button>
            <div id="howto-body" class="collapsible-body" role="region" aria-label="Instructions">
                <p style="font-size: 10px; line-height: 1.7; color: #0088ff; padding: 6px 0 0 0;">
                    üñ±Ô∏è Drag to orbit ¬∑ üìú Scroll to zoom ¬∑ üëÜ Click to focus
                </p>
            </div>
        </div>
        <div class="filter-section">
            <button type="button" class="filter-toggle" id="filter-toggle" aria-expanded="false" aria-controls="filter-list">
                <span>Jump to node</span>
                <span id="filter-chevron">‚ñº</span>
            </button>
            <div id="filter-list" class="filter-list" role="region" aria-label="Node list by category"></div>
        </div>
        <div id="detailPanel" class="is-empty">
            <h3>Info</h3>
            <div id="nodeDetails" class="detail-inner">
                <p id="detailName" style="color: #ffff99; font-weight: bold; margin-bottom: 4px;"></p>
                <p id="detailType" style="color: #00ffff;"></p>
                <p id="detailDesc" style="color: #aaa; font-style: italic; margin: 6px 0 8px 0;"></p>
                <p style="color: #00ffff; font-weight: bold; margin-bottom: 4px;">Connected to</p>
                <div id="detailConnections" style="font-size: 9px; color: #888;"></div>
            </div>
        </div>
        </div>
        <div class="panel-buttons">
            <button class="primary" onclick="walk()">‚ö° Random Pulse</button>
            <button class="primary" onclick="clearSelection()">‚úï Clear</button>
            <button class="primary" onclick="reset()">‚Üª Reset Mind</button>
        </div>
        </div>
        <div class="panel-legend">
            <button type="button" class="collapsible-trigger" id="legend-toggle" aria-expanded="false" aria-controls="legend-body">
                <span>Legend</span>
                <span id="legend-chevron">‚ñº</span>
            </button>
            <div id="legend-body" class="collapsible-body legend-open" role="region" aria-label="Category legend">
                <div class="legend-grid" style="padding-top: 8px;">
                    <div class="legend-item"><div class="legend-dot" style="background: #00ffff; box-shadow: 0 0 6px #00ffff;"></div><span style="color: #00ffff;">Activities</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background: #ff00aa; box-shadow: 0 0 6px #ff00aa;"></div><span style="color: #ff00aa;">People</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background: #00ff88; box-shadow: 0 0 6px #00ff88;"></div><span style="color: #00ff88;">Locations</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background: #ffaa00; box-shadow: 0 0 6px #ffaa00;"></div><span style="color: #ffaa00;">Temporal</span></div>
                    <div class="legend-item"><div class="legend-dot" style="background: #aa00ff; box-shadow: 0 0 6px #aa00ff;"></div><span style="color: #aa00ff;">Emotions</span></div>
                </div>
            </div>
        </div>
    </div>
    <div id="filter-bar">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="today">Today</button>
        <button class="filter-btn" data-filter="people">People</button>
        <button class="filter-btn" data-filter="locations">Locations</button>
        <button class="filter-btn" data-filter="activities">Activities</button>
    </div>
    <canvas id="canvas"></canvas>
    <button type="button" id="panel-toggle" aria-label="Toggle panel">‚Äπ</button>
    
    <!-- Mobile Bottom Drawer -->
    <div id="bottomDrawer" class="bottom-drawer">
        <div class="drawer-handle"></div>
        <div id="drawerFilters" class="drawer-filters">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="today">Today</button>
            <button class="filter-btn" data-filter="people">People</button>
            <button class="filter-btn" data-filter="locations">Locations</button>
            <button class="filter-btn" data-filter="activities">Activities</button>
        </div>
        <div id="drawerContent" class="drawer-content">
            <div id="drawerDetails"></div>
        </div>
    </div>

    <div style="position: fixed; bottom: 12px; left: 12px; font-size: 10px; color: #94a3b8; z-index: 20;">
        <div><a href="../latest/" style="color: #06b6d4; text-decoration: none; font-weight: bold;">‚Üª Latest</a></div>
        <div><a href="../claw/" style="color: #fbbf24; text-decoration: none; font-weight: bold;">‚öôÔ∏è Claude Code</a></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', {alpha: true});
        const infoPanel = document.getElementById('info');
        const panelToggle = document.getElementById('panel-toggle');

        const PANEL_WIDTH = 240;
        let panelOpen = true;

        function getCanvasWidth() {
            return panelOpen ? window.innerWidth - PANEL_WIDTH : window.innerWidth;
        }
        function resizeCanvas() {
            canvas.width = getCanvasWidth();
            canvas.height = window.innerHeight;
            if (canvas.style) canvas.style.marginRight = panelOpen ? PANEL_WIDTH + 'px' : '0';
        }
        function togglePanel() {
            panelOpen = !panelOpen;
            infoPanel.classList.toggle('collapsed', !panelOpen);
            panelToggle.textContent = panelOpen ? '‚Äπ' : '‚Ä∫';
            panelToggle.setAttribute('aria-label', panelOpen ? 'Collapse panel' : 'Expand panel');
            resizeCanvas();
        }

        resizeCanvas();
        panelToggle.addEventListener('click', togglePanel);

        window.addEventListener('resize', function() {
            resizeCanvas();
        });
        window.addEventListener('orientationchange', function() {
            setTimeout(resizeCanvas, 100);
        });

        // Category to color mapping
        const categoryColors = {
            'activity': '#00ffff',
            'person': '#ff00aa',
            'location': '#00ff88',
            'emotion': '#aa00ff',
            'temporal': '#ffaa00',
            'region': '#8800ff'  // Purple for geographic regions
        };

        let nodes = [];
        let edges = [];

        // Use embedded fallback when fetch won't work (file:// or offline)
        function useFallbackGraph() {
            nodes = [
                { id: 0, name: 'Paul', type: 'person', x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, size: 10, color: '#FF6B6B', glow: 22, freq: 100, desc: 'Urban Runner, digital nomad' },
                { id: 1, name: 'Volleyball', type: 'activity', x: 80, y: -60, z: 40, vx: 0, vy: 0, vz: 0, size: 9, color: '#00ffff', glow: 20, freq: 50, desc: '18 years of competition, flow state' },
                { id: 2, name: 'Bangkok', type: 'location', x: -70, y: 50, z: -50, vx: 0, vy: 0, vz: 0, size: 8, color: '#00ff88', glow: 18, freq: 40, desc: 'Primary base, Urban Runner epicenter' }
            ];
            edges = [
                { from: 0, to: 1, weight: 8 },
                { from: 0, to: 2, weight: 7 },
                { from: 1, to: 2, weight: 6 }
            ];
            populateFilterList();
            render();
            if (nodes.length > 0) {
                selected = Math.floor(Math.random() * nodes.length);
                showNodeDetails(nodes[selected]);
            }
        }

        // Load data from JSON files. (file:// cannot fetch ‚Äî use fallback and avoid CORS errors.)
        async function loadGraphData() {
            if (window.location.protocol === 'file:') {
                console.info('Serving from file:// ‚Äî use a local server (e.g. npx serve) or GitHub Pages to load full data.');
                useFallbackGraph();
                return;
            }
            try {
                const nodesResponse = await fetch('./data/nodes-100pct.json?t=' + Date.now());
                if (!nodesResponse.ok) {
                    throw new Error(`Nodes fetch failed: ${nodesResponse.status}`);
                }
                const rawNodes = await nodesResponse.json();
                if (!rawNodes || rawNodes.length === 0) {
                    throw new Error('Nodes JSON is empty');
                }

                nodes = rawNodes.map((n, idx) => {
                    const angle = (idx / rawNodes.length) * Math.PI * 2;
                    const radius = 280 + Math.random() * 220;
                    const x = Math.cos(angle) * radius;
                    const y = (Math.random() - 0.5) * 500;
                    const z = Math.sin(angle) * radius;
                    // Regions are bigger and brighter
                    const baseSize = n.category === 'region' ? 12 : 6;
                    const sizeBoost = n.category === 'region' ? 3 : 1;
                    const size = baseSize + (n.frequency / 85) * 10 * sizeBoost;
                    const glow = size * 2.5;
                    const color = categoryColors[n.category] || n.attributes?.color || '#00ffff';
                    return {
                        id: idx,
                        idKey: n.id,
                        name: n.label,
                        type: n.category,
                        x, y, z,
                        vx: 0, vy: 0, vz: 0,
                        size,
                        glow,
                        color,
                        freq: n.frequency,
                        desc: n.attributes?.description || ''
                    };
                });

                const synapsesResponse = await fetch('./data/synapses-100pct.json?t=' + Date.now());
                if (!synapsesResponse.ok) {
                    throw new Error(`Synapses fetch failed: ${synapsesResponse.status}`);
                }
                const rawSynapses = await synapsesResponse.json();
                if (!rawSynapses || rawSynapses.length === 0) {
                    throw new Error('Synapses JSON is empty');
                }

                edges = rawSynapses.map(s => {
                    const fromIdx = nodes.findIndex(n => n.idKey === s.source);
                    const toIdx = nodes.findIndex(n => n.idKey === s.target);
                    if (fromIdx >= 0 && toIdx >= 0) {
                        return { from: fromIdx, to: toIdx, weight: Math.round(s.weight * 10) };
                    }
                    return null;
                }).filter(e => e !== null);

                console.log(`‚úÖ Loaded ${nodes.length} neurons and ${edges.length} synapses`);
                populateFilterList();
                render();
                if (nodes.length > 0) {
                    selected = Math.floor(Math.random() * nodes.length);
                    showNodeDetails(nodes[selected]);
                }
            } catch (e) {
                console.error('‚ùå Graph data fetch FAILED:', e.message, e);
                console.log('Attempted to fetch: ./data/nodes-100pct.json?t=' + Date.now());
                console.log('Window location:', window.location.href);
                useFallbackGraph();
            }
        }

        let camera = {angle: 0.5, dist: 680, height: 0, pitch: 0};
        let viewZoom = 1;   // 2D scale of the graph (zoom in = focus on nodes, zoom out = big picture)
        const VIEW_ZOOM_MIN = 0.25;
        const VIEW_ZOOM_MAX = 5;
        let selected = null;
        let time = 0;
        let particles = [];

        function project(x, y, z) {
            const cos = Math.cos(camera.angle);
            const sin = Math.sin(camera.angle);
            const rx = x * cos - z * sin;
            const rz = x * sin + z * cos;
            const cp = Math.cos(camera.pitch);
            const sp = Math.sin(camera.pitch);
            const viewY = y * cp - rz * sp;
            const viewZ = y * sp + rz * cp;
            const scale = camera.dist / (camera.dist + viewZ + 200);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            let sx = cx + rx * scale;
            let sy = cy + (viewY + camera.height) * scale;
            // Apply 2D view zoom around center (so pinch/scroll scales the whole graph)
            sx = cx + (sx - cx) * viewZoom;
            sy = cy + (sy - cy) * viewZoom;
            return {
                x: sx,
                y: sy,
                z: viewZ,
                scale: Math.max(0.1, scale) * viewZoom
            };
        }

        function step() {
            // Kill all movement - nodes stay in place
            nodes.forEach(n => {
                n.vx = 0;
                n.vy = 0;
                n.vz = 0;
            });
        }

        function render() {
            try {
                time++;
                
                ctx.fillStyle = '#0a1128';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const sorted = nodes.map(n => {
                    const p = project(n.x, n.y, n.z);
                    return {node: n, proj: p};
                }).sort((a, b) => a.proj.z - b.proj.z);

                // When a node is selected, only it and its connections stay bright
                let activeNodeIds = null;
                if (selected !== null) {
                    activeNodeIds = new Set([selected]);
                    edges.forEach(e => {
                        if (e.from === selected) activeNodeIds.add(e.to);
                        if (e.to === selected) activeNodeIds.add(e.from);
                    });
                }

                // Helper to check if node passes current filter
                const passesFilter = (nodeIndex) => {
                    const n = nodes[nodeIndex];
                    if (currentFilter === 'all') return true;
                    if (currentFilter === 'people') return n.type === 'person';
                    if (currentFilter === 'locations') return n.type === 'location';
                    if (currentFilter === 'activities') return n.type === 'activity';
                    if (currentFilter === 'today') return n.isToday;
                    return true;
                };

                // Draw synapses with triple glow
                edges.forEach(e => {
                    // Skip edges if either node is filtered out
                    if (!passesFilter(e.from) || !passesFilter(e.to)) return;
                    
                    const p1 = project(nodes[e.from].x, nodes[e.from].y, nodes[e.from].z);
                    const p2 = project(nodes[e.to].x, nodes[e.to].y, nodes[e.to].z);
                    const isConnected = selected !== null && (e.from === selected || e.to === selected);
                    const strength = 0.4 + (e.weight / 15) * 0.6;
                    
                    if (isConnected) {
                        // Highlight: connected to selected node ‚Äî yellow/white glow on top
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.strokeStyle = 'rgba(255, 255, 200, 0.35)';
                        ctx.lineWidth = Math.max(8, e.weight / 1.5) + 4;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.strokeStyle = 'rgba(255, 255, 150, 0.7)';
                        ctx.lineWidth = Math.max(3, e.weight / 2.5) + 1;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.strokeStyle = '#ffff88';
                        ctx.lineWidth = Math.max(1.5, e.weight / 4);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    } else {
                        // Not connected to selected ‚Äî dim like non-selected nodes
                        const edgeDimAlpha = activeNodeIds !== null ? 0.22 : 1;
                        ctx.globalAlpha = edgeDimAlpha;
                        ctx.strokeStyle = `rgba(0, 100, 255, ${strength * 0.2})`;
                        ctx.lineWidth = Math.max(4, e.weight / 2.5) + 2;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.strokeStyle = `rgba(0, 200, 255, ${strength * 0.4})`;
                        ctx.lineWidth = Math.max(2, e.weight / 3.5) + 1;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.strokeStyle = `rgba(0, 255, 255, ${strength})`;
                        ctx.lineWidth = Math.max(0.5, e.weight / 5);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                });

                // Draw neurons
                const dimAlpha = 0.22;
                sorted.forEach(item => {
                    const n = item.node;
                    const p = item.proj;
                    
                    // Filter logic: check if node should be visible
                    if (currentFilter === 'people' && n.type !== 'person') return;
                    if (currentFilter === 'locations' && n.type !== 'location') return;
                    if (currentFilter === 'activities' && n.type !== 'activity') return;
                    if (currentFilter === 'today' && !n.isToday) return; // Optional: requires node.isToday flag
                    
                    const r = n.size * p.scale;
                    const glow = n.glow * p.scale;
                    const isDimmed = activeNodeIds !== null && !activeNodeIds.has(n.id);
                    if (isDimmed) ctx.globalAlpha = dimAlpha;

                    // Outer halo
                    const g1 = ctx.createRadialGradient(p.x, p.y, r*0.5, p.x, p.y, glow*2);
                    const [r2, g2, b2] = [
                        parseInt(n.color.slice(1,3), 16),
                        parseInt(n.color.slice(3,5), 16),
                        parseInt(n.color.slice(5,7), 16)
                    ];
                    g1.addColorStop(0, `rgba(${r2}, ${g2}, ${b2}, 0.6)`);
                    g1.addColorStop(0.5, `rgba(${r2}, ${g2}, ${b2}, 0.15)`);
                    g1.addColorStop(1, `rgba(${r2}, ${g2}, ${b2}, 0)`);
                    ctx.fillStyle = g1;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, glow*2, 0, 6.28);
                    ctx.fill();

                    // Inner glow
                    const g2_grad = ctx.createRadialGradient(p.x, p.y, r*0.2, p.x, p.y, glow);
                    g2_grad.addColorStop(0, `rgba(${r2}, ${g2}, ${b2}, 1)`);
                    g2_grad.addColorStop(0.5, `rgba(${r2}, ${g2}, ${b2}, 0.4)`);
                    g2_grad.addColorStop(1, `rgba(${r2}, ${g2}, ${b2}, 0)`);
                    ctx.fillStyle = g2_grad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, glow, 0, 6.28);
                    ctx.fill();

                    // Core neuron
                    ctx.fillStyle = n.color;
                    ctx.shadowColor = n.color;
                    ctx.shadowBlur = 25;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, 6.28);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Selection highlight
                    if (selected === n.id) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 4;
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, r + 12, 0, 6.28);
                        ctx.stroke();
                        
                        // Pulsing ring
                        const pulse = Math.sin(time * 0.05) * 0.3 + 0.7;
                        ctx.strokeStyle = `rgba(255, 255, 0, ${pulse * 0.6})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, r + 20, 0, 6.28);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }

                    // Label with glow
                    ctx.fillStyle = n.color;
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = n.color;
                    ctx.shadowBlur = 10;
                    ctx.globalAlpha = isDimmed ? dimAlpha * 0.9 : 0.85;
                    ctx.fillText(n.name, p.x, p.y + r + 18);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                });

                document.getElementById('count').textContent = nodes.length;
                document.getElementById('status').textContent = selected !== null ? `üß† ${nodes[selected].name}` : '‚Äî';

                step();
                requestAnimationFrame(render);
            } catch (e) {
                console.error('Render error:', e);
            }
        }

        // Filter bar functionality (desktop)
        let currentFilter = 'all';
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                console.log('Filter applied:', currentFilter);
            });
        });
        
        // Mobile drawer functionality
        let drawerStartY = 0;
        let drawerOpen = false;
        
        const drawer = document.getElementById('bottomDrawer');
        const drawerHandle = document.querySelector('.drawer-handle');
        
        drawerHandle.addEventListener('mousedown', (e) => {
            drawerStartY = e.clientY;
        });
        
        drawerHandle.addEventListener('touchstart', (e) => {
            drawerStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (drawerStartY && drawerOpen) {
                const delta = e.clientY - drawerStartY;
                if (delta > 100) {
                    drawer.classList.remove('open');
                    drawerOpen = false;
                    drawerStartY = 0;
                }
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (drawerStartY && drawerOpen) {
                const delta = e.touches[0].clientY - drawerStartY;
                if (delta > 100) {
                    drawer.classList.remove('open');
                    drawerOpen = false;
                    drawerStartY = 0;
                }
            }
        });
        
        // Filter buttons in drawer
        document.querySelectorAll('#drawerFilters .filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#drawerFilters .filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
            });
        });

        canvas.addEventListener('click', e => {
            if (hitTestNode(e.clientX, e.clientY)) {
                // Node was clicked - switch to "All" filter to show all connections
                if (currentFilter !== 'all') {
                    currentFilter = 'all';
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('[data-filter="all"]').classList.add('active');
                    document.querySelectorAll('#drawerFilters .filter-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('#drawerFilters [data-filter="all"]').classList.add('active');
                }
                // Update URL hash for deep linking
                if (selected !== null) {
                    const selectedNode = nodes[selected];
                    window.location.hash = selectedNode.id;
                    
                    // On mobile: open drawer
                    if (window.innerWidth <= 768) {
                        drawer.classList.add('open');
                        drawerOpen = true;
                        showNodeDetailsInDrawer(selectedNode);
                    }
                }
            }
        });
        
        // Helper function to show details in drawer
        function showNodeDetailsInDrawer(node) {
            const content = document.getElementById('drawerDetails');
            const detailPanel = document.getElementById('detailPanel');
            
            // Copy the content from detail panel or regenerate
            showNodeDetails(node);
            
            // Populate drawer with node info
            content.innerHTML = `
                <h2>${node.name}</h2>
                <p style="font-size: 12px; color: #888; margin-top: 8px;">Type: ${node.type}</p>
                <p style="margin-top: 12px; line-height: 1.6;">${node.desc || 'No description'}</p>
            `;
        }

        // Handle URL hash navigation
        function handleHashNavigation() {
            const hash = window.location.hash.substring(1); // Remove the #
            if (hash && nodes.length > 0) {
                const nodeIndex = nodes.findIndex(n => n.id === hash);
                if (nodeIndex !== -1) {
                    selected = nodeIndex;
                    showNodeDetails(nodes[selected]);
                    // Switch to All filter to show connections
                    if (currentFilter !== 'all') {
                        currentFilter = 'all';
                        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                        document.querySelector('[data-filter="all"]').classList.add('active');
                    }
                }
            }
        }

        // Listen for hash changes (back/forward buttons, direct URL visits)
        window.addEventListener('hashchange', handleHashNavigation);

        // Check for hash on page load
        loadGraphData().then(() => {
            // Check URL hash first, otherwise pick random node
            if (window.location.hash) {
                handleHashNavigation();
            } else if (nodes.length > 0) {
                selected = Math.floor(Math.random() * nodes.length);
                showNodeDetails(nodes[selected]);
            }
        });

        window.clearSelection = () => {
            selected = null;
            showNodeDetails(null);
        };
        
        // Character profiles (loaded from characters.js data)
        let characterProfiles = {};
        async function loadCharacterProfiles() {
            try {
                const response = await fetch('./characters/characters.js');
                if (!response.ok) return;
                const text = await response.text();
                // Parse characters array from the JS file
                const match = text.match(/const characters = \[([\s\S]*?)\];/);
                if (match) {
                  eval('characterProfiles = ' + '[' + match[1] + ']');
                  // Build lookup by id
                  const profiles = {};
                  if (Array.isArray(characterProfiles)) {
                    characterProfiles.forEach(char => {
                      profiles[char.id] = char;
                    });
                  }
                  characterProfiles = profiles;
                }
            } catch (e) {
                console.warn('Could not load character profiles:', e);
            }
        }

        function showNodeDetails(node) {
            const panel = document.getElementById('detailPanel');
            const detailName = document.getElementById('detailName');
            const detailType = document.getElementById('detailType');
            const detailDesc = document.getElementById('detailDesc');
            const detailConnections = document.getElementById('detailConnections');
            
            if (!node) {
                panel.classList.add('is-empty');
                detailName.textContent = '';
                detailType.textContent = '';
                detailDesc.textContent = '';
                detailConnections.innerHTML = '';
                return;
            }
            
            panel.classList.remove('is-empty');
            
            // Check if this is a person node with character profile
            if (node.type === 'person' && characterProfiles[node.idKey]) {
                const char = characterProfiles[node.idKey];
                detailName.innerHTML = `<img src="${char.avatar}" style="width: 100%; height: auto; border-radius: 8px; margin-bottom: 12px;" alt="${char.name}">
                                        <span style="color: #fbbf24; font-weight: bold;">${char.name}</span>`;
                detailType.textContent = `${char.role}`;
                detailDesc.textContent = char.bio;
                
                // Add episode links if available
                let connectionHTML = '';
                if (char.episodes && char.episodes.length > 0) {
                    connectionHTML += '<p style="color: #00ffff; font-weight: bold; margin-top: 12px;">Episodes:</p>';
                    connectionHTML += char.episodes.map(ep => 
                        `<div style="margin: 4px 0; color: #fbbf24; font-size: 10px;">${ep}</div>`
                    ).join('');
                }
                detailConnections.innerHTML = connectionHTML || '<div style="color: #666; font-size: 10px;">No episodes linked</div>';
            } else {
                // Standard node display
                detailName.textContent = node.name;
                detailType.textContent = `Type: ${node.type.charAt(0).toUpperCase() + node.type.slice(1)}`;
                detailDesc.textContent = node.desc;
                
                // Find connected nodes
                const connected = [];
                edges.forEach(e => {
                    if (e.from === node.id) {
                        const target = nodes[e.to];
                        connected.push(`‚Üí ${target.name} (${target.type})`);
                    } else if (e.to === node.id) {
                        const source = nodes[e.from];
                        connected.push(`‚Üê ${source.name} (${source.type})`);
                    }
                });
                
                detailConnections.innerHTML = connected.length > 0 
                    ? connected.map(c => `<div style="margin: 4px 0; color: #00ffff;">${c}</div>`).join('')
                    : '<div style="color: #666;">No connections</div>';
            }
        }

        // Mobile drawer management
        function openDrawer() {
            const info = document.getElementById('info');
            const canvas = document.getElementById('canvas');
            if (window.innerWidth <= 768) {
                info.classList.add('open');
                canvas.classList.add('drawer-open');
            }
        }

        function closeDrawer() {
            const info = document.getElementById('info');
            const canvas = document.getElementById('canvas');
            info.classList.remove('open');
            canvas.classList.remove('drawer-open');
        }

        window.selectNodeByIndex = function(idx) {
            if (idx < 0 || idx >= nodes.length) return;
            selected = idx;
            showNodeDetails(nodes[selected]);
            openDrawer();
        };

        const filterCategoryOrder = ['region', 'person', 'location', 'activity', 'temporal', 'emotion'];
        const filterCategoryLabels = { region: 'Regions', person: 'People', location: 'Locations', activity: 'Activities', temporal: 'Temporal', emotion: 'Emotions' };

        function populateFilterList() {
            const listEl = document.getElementById('filter-list');
            if (!listEl || nodes.length === 0) return;
            const byCategory = { person: [], location: [], activity: [], region: [], temporal: [], emotion: [] };
            nodes.forEach((n, idx) => {
                const t = (n.type || '').toLowerCase();
                if (byCategory[t]) byCategory[t].push({ node: n, idx });
            });
            listEl.innerHTML = '';
            filterCategoryOrder.forEach(cat => {
                const items = byCategory[cat];
                if (!items || items.length === 0) return;
                const label = filterCategoryLabels[cat] || cat;
                const color = categoryColors[cat] || '#00ffff';
                const heading = document.createElement('h4');
                heading.textContent = label;
                heading.style.color = color;
                listEl.appendChild(heading);
                items.forEach(({ node, idx }) => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'filter-node';
                    btn.textContent = node.name;
                    btn.style.color = color;
                    btn.addEventListener('click', () => selectNodeByIndex(idx));
                    listEl.appendChild(btn);
                });
            });
        }

        document.getElementById('filter-toggle').addEventListener('click', () => {
            const list = document.getElementById('filter-list');
            const chevron = document.getElementById('filter-chevron');
            const isOpen = list.classList.toggle('open');
            chevron.textContent = isOpen ? '‚ñ≤' : '‚ñº';
            document.getElementById('filter-toggle').setAttribute('aria-expanded', isOpen);
        });
        document.getElementById('howto-toggle').addEventListener('click', () => {
            const body = document.getElementById('howto-body');
            const chevron = document.getElementById('howto-chevron');
            const isOpen = body.classList.toggle('open');
            chevron.textContent = isOpen ? '‚ñ≤' : '‚ñº';
            document.getElementById('howto-toggle').setAttribute('aria-expanded', isOpen);
        });
        document.getElementById('legend-toggle').addEventListener('click', () => {
            const body = document.getElementById('legend-body');
            const chevron = document.getElementById('legend-chevron');
            const isOpen = body.classList.toggle('open');
            chevron.textContent = isOpen ? '‚ñ≤' : '‚ñº';
            document.getElementById('legend-toggle').setAttribute('aria-expanded', isOpen);
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            // Scale the whole graph (scroll up / pinch out = zoom in, scroll down = zoom out)
            const zoomSpeed = 0.002;
            viewZoom *= 1 - e.deltaY * zoomSpeed;
            viewZoom = Math.max(VIEW_ZOOM_MIN, Math.min(VIEW_ZOOM_MAX, viewZoom));
        });

        let pinchDist = null;
        let touchStartX = 0, touchStartY = 0, lastTouchX = 0, lastTouchY = 0;
        let touchMoved = false;
        let touchFingerCount = 0;
        const TAP_THRESHOLD = 12;

        function pinchDistance(touches) {
            return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
        }

        function hitTestNode(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;
            for (let n of nodes) {
                const p = project(n.x, n.y, n.z);
                const d = Math.hypot(p.x - mx, p.y - my);
                if (d < n.size * p.scale + 25) {
                    selected = selected === n.id ? null : n.id;
                    showNodeDetails(selected !== null ? nodes[selected] : null);
                    return true;
                }
            }
            return false;
        }

        canvas.addEventListener('touchstart', e => {
            touchFingerCount = e.touches.length;
            if (e.touches.length === 2) {
                pinchDist = pinchDistance(e.touches);
                e.preventDefault();
            } else if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastTouchX = touchStartX;
                lastTouchY = touchStartY;
                touchMoved = false;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const d = pinchDistance(e.touches);
                if (pinchDist === null) { pinchDist = d; return; }
                // Pinch out (d > pinchDist) = zoom in = increase viewZoom
                const ratio = d / pinchDist;
                viewZoom *= ratio;
                viewZoom = Math.max(VIEW_ZOOM_MIN, Math.min(VIEW_ZOOM_MAX, viewZoom));
                pinchDist = d;
            } else if (e.touches.length === 1) {
                const dx = e.touches[0].clientX - lastTouchX;
                const dy = e.touches[0].clientY - lastTouchY;
                if (!touchMoved) touchMoved = Math.hypot(e.touches[0].clientX - touchStartX, e.touches[0].clientY - touchStartY) > TAP_THRESHOLD;
                if (touchMoved) {
                    e.preventDefault();
                    camera.angle += dx * 0.012;
                    camera.pitch += dy * 0.008;
                    camera.pitch = Math.max(-1.2, Math.min(1.2, camera.pitch));
                }
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            if (e.touches.length < 2) pinchDist = null;
            if (e.touches.length === 0 && touchFingerCount === 1 && !touchMoved && e.changedTouches[0]) {
                const t = e.changedTouches[0];
                hitTestNode(t.clientX, t.clientY);
            }
        }, { passive: true });

        let drag = null;
        canvas.addEventListener('mousedown', e => {
            drag = {x: e.clientX, y: e.clientY};
        });
        document.addEventListener('mousemove', e => {
            if (drag) {
                camera.angle += (e.clientX - drag.x) * 0.012;
                camera.pitch += (e.clientY - drag.y) * 0.008;
                camera.pitch = Math.max(-1.2, Math.min(1.2, camera.pitch));
                drag = {x: e.clientX, y: e.clientY};
            }
        });
        document.addEventListener('mouseup', () => {
            drag = null;
        });

        window.walk = () => {
            selected = Math.floor(Math.random() * nodes.length);
            showNodeDetails(nodes[selected]);
        };

        window.reset = () => {
            camera = {angle: 0.5, dist: 680, height: 0, pitch: 0};
            viewZoom = 1;
            selected = null;
            showNodeDetails(null);
        };

        // Start rendering immediately (will display as data loads)
        render();
        
        // Load character profiles, then graph data
        // Unregister old service workers that were caching aggressively
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(registrations => {
                registrations.forEach(reg => {
                    console.log('Unregistering service worker:', reg);
                    reg.unregister();
                });
            }).catch(err => console.log('No service workers to unregister:', err));
        }
        
        loadCharacterProfiles();
        
        loadGraphData().then(() => {
            // Check URL hash first, otherwise pick random node
            if (window.location.hash) {
                handleHashNavigation();
            } else if (nodes.length > 0) {
                selected = Math.floor(Math.random() * nodes.length);
                showNodeDetails(nodes[selected]);
            }
        });
    </script>
    <!-- Deployment verification: 2026-02-22 15:31:58 UTC -->
    <div style="position: fixed; bottom: 10px; left: 10px; font-size: 8px; color: #00ff00; opacity: 0.3; pointer-events: none; z-index: 1;">
        v:2026-02-22-15:31:58
    </div>
</body>
</html>
